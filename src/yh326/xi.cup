// A stub for a Xi CUP specification.

package yh326;

// You might want to add types to these declarations.
terminal String IDENTIFIER;
terminal String STRING_LITERAL;
terminal Character CHARACTER_LITERAL;
terminal UnsignedLong INTEGER_LITERAL;
terminal TRUE, FALSE;
terminal INT, BOOL;

terminal IF, ELSE, WHILE, BREAK, RETURN, USE, LENGTH, PLUS, MINUS, TIMES,
  DIVIDE, MODULO, NOT, LT, LEQ, GT, GEQ, AND, OR, EQUAL, NOT_EQUAL, GETS,
  OPEN_BRACKET, CLOSE_BRACKET, OPEN_PAREN, CLOSE_PAREN, OPEN_BRACE, CLOSE_BRACE,
  COLON, COMMA, SEMICOLON, UNDERSCORE;

terminal TIMES_SHIFT, ERROR;

// You might want to add types to these declarations.
nonterminal Node program, use_list, use, method_list, method,
                 method_args, var_decl_list, method_retvals, retvals,
                 type, primitive_type, array_type, block, stmt_list,
                 stmt, var_decl, assignment, lhs, expr, unary_op,
                 binary_op, value, literal, array_literal, literal_list,
                 length_statement, return_statement, method_call,
                 expr_list, nothing
                 ;

/* precedence & associativity declarations */
precedence left OR;
precedence left AND;
precedence left EQUAL, NOT_EQUAL;
precedence left GT, LT, GEQ, LEQ;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MODULO, TIMES_SHIFT;
precedence left NOT; //<-- TODO: arithmetic negation (minus)


start with program;

program          ::= use_list:ul method_list:ml
                       {: Node.write(new Node(ul, ml)); :};

/* ================= USE ==================================================== */
use_list         ::= use:u use_list:ul {: RESULT = new Node(u).addChildren(ul); :}
                   | use:u             {: RESULT = new Node(u); :};
use              ::= USE IDENTIFIER:id
                       {: RESULT = new Node(new Node("use"), new Node(id)); :};

/* ================= METHOD ================================================= */
method_list      ::= method:m method_list:ml {: RESULT = new Node(m).addChildren(ml); :}
                   | method:m                {: RESULT = new Node(m); :};
method           ::= IDENTIFIER:id method_args:args method_retvals:mr block:b
                       {: RESULT = new Node(new Node(id), args, mr, b); :};
method_args      ::= OPEN_PAREN var_decl_list:vds CLOSE_PAREN
                       {: RESULT = vds; :};

/* ================= VARIABLE DECLARATION =================================== */
var_decl_list    ::= var_decl:vd COMMA var_decl_list:vdl //<-- for now, allow trailing commas
                       {: RESULT = new Node(vd).addChildren(vdl); :}
                   | var_decl:vd {: RESULT = new Node(vd); :}
                   | nothing;
var_decl         ::= IDENTIFIER:id COLON type:type
                       {: RESULT = new Node(new Node(id), type); :};

/* ================= TYPE =================================================== */
type             ::= primitive_type:pt  {: RESULT = pt; :}
                   | array_type:at      {: RESULT = at; :};
primitive_type   ::= INT                {: RESULT = new Node("int"); :}
                   | BOOL               {: RESULT = new Node("bool"); :};
array_type       ::= array_type:at OPEN_BRACKET CLOSE_BRACKET
                       {: RESULT = new Node(new Node("[]"), at); :}
                   | primitive_type:pt OPEN_BRACKET CLOSE_BRACKET
                       {: RESULT = new Node(new Node("[]"), pt); :};

/* ================= RETVAL ================================================= */
method_retvals   ::= COLON retvals:rv   {: RESULT = rv; :}
                   | nothing;
retvals          ::= type:t COMMA retvals:rv {: RESULT = new Node(t).addChildren(rv); :}
                   | type:t                  {: RESULT = new Node(t); :};

/* ================= BLOCK ================================================== */
block            ::= OPEN_BRACE stmt_list:sl CLOSE_BRACE
                       {: RESULT = sl; :};
stmt_list        ::= stmt:st stmt_list:sl
                       {: RESULT = new Node(st).addChildren(sl); :}
                   | nothing;
stmt             ::= stmt:st SEMICOLON      {: RESULT = st; :}
                   | var_decl:vd            {: RESULT = vd; :}
                   | block
                   | assignment:as          {: RESULT = as; :}
                   | method_call
                   | return_statement
                   | length_statement;
assignment       ::= lhs:lhs GETS expr:expr {: RESULT = new Node(new Node("="), lhs, expr); :};
lhs              ::= var_decl:vd            {: RESULT = vd; :}
                   | IDENTIFIER:id          {: RESULT = new Node(id); :}; //TODO: array index access?
expr             ::= unary_op expr
                   | expr binary_op expr
                   | OPEN_PAREN expr CLOSE_PAREN
                   | value;
unary_op         ::= NOT;     //TODO: arithmetic negation (minus)
binary_op        ::= PLUS
                   | MINUS
                   | TIMES
                   | DIVIDE
                   | MODULO
                   | LT
                   | GT
                   | LEQ
                   | GEQ
                   | AND
                   | OR
                   | EQUAL
                   | NOT_EQUAL
                   | TIMES_SHIFT;
value            ::= IDENTIFIER
                   | literal;    //TODO: array index access?
literal          ::= INTEGER_LITERAL
                   | STRING_LITERAL
                   | CHARACTER_LITERAL
                   | array_literal;
array_literal    ::= OPEN_BRACE literal_list CLOSE_BRACE;
literal_list     ::= literal COMMA literal_list   //<-- for now, allow trailing commas
                   | literal
                   | nothing;
method_call      ::= IDENTIFIER OPEN_PAREN expr_list CLOSE_PAREN;
expr_list        ::= expr COMMA expr_list         //<-- for now, allow trailing commas
                   | expr
                   | nothing;
return_statement ::= RETURN expr;
length_statement ::= LENGTH OPEN_PAREN expr CLOSE_PAREN;

nothing          ::= /* placeholder for epsilon */;
