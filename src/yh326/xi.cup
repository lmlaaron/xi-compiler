package yh326;

parser code  {:
  public void p(String s) {System.out.println(s);}
  public void report_error(String message, Object info) {}
  public void report_expected_token_ids() {}

  public void report_fatal_error(String message, Object info) {
    if (info instanceof XiSymbol) {
      XiSymbol s = (XiSymbol) info;
      String p = "" + s.getLine() + ":" + s.getColumn() + " ";
        if (s.sym == sym.ERROR) {
          p += s.value;
        } else {
          p += "error: Unexpected token " + s.value;
        }
      System.out.println(p);
    }
  }
:};

terminal String IDENTIFIER;
terminal String STRING_LITERAL;
terminal String CHARACTER_LITERAL;
terminal String INTEGER_LITERAL;
terminal TRUE, FALSE;
terminal INT, BOOL;

terminal IF, ELSE, WHILE, /*BREAK,*/ RETURN, USE, LENGTH, PLUS, MINUS, TIMES,
  DIVIDE, MODULO, NOT, LT, LEQ, GT, GEQ, AND, OR, EQUAL, NOT_EQUAL, GETS,
  OPEN_BRACKET, CLOSE_BRACKET, OPEN_PAREN, CLOSE_PAREN, OPEN_BRACE, CLOSE_BRACE,
  COLON, COMMA, SEMICOLON, UNDERSCORE;

// These two are not include in the give xi.cup
terminal TIMES_SHIFT, ERROR;

nonterminal Node program, use_list, use, method_list, method, interface_list, interface,
                 method_args, var_decl_list, var_decl_rec, method_retvals, retvals,
                 type, primitive_type, array_type, block, stmt_list,
                 stmt, stmt_cond, stmt_semi, var_decl, assignment, lhs,
                 expr_list, expr_rec, expr, var, box, boxes,
                 value, array_literal, index, indexes,
                 if_statement, while_statement, else_statement,
                 length_statement, return_statement, return_core, method_call,
                 expr_atom, nothing,
                 expr_t1, expr_t2, expr_t3, expr_t4, expr_t5, expr_t6, expr_t7,
                 t1op, t2op, t3op, t4op, t5op, t6op, t7op ;

/* precedence & associativity declarations */
// Note that precedence rules below are kept but are actually not helping the parser
precedence left OR;
precedence left AND;
precedence left EQUAL, NOT_EQUAL;
precedence left GT, LT, GEQ, LEQ;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MODULO, TIMES_SHIFT;

start with program;

program          ::= use_list:ul method_list:ml {: Node.write(new Node(ul, ml)); :}
                   | method_list:ml             {: Node.write(new Node(null,ml)); :}
                   | interface_list:il          {: Node.write(new Node(il)); :}
                   | use_list:ul                {: Node.write(new Node(ul, null)); :}
                   | nothing                    {: Node.write(new Node(null, null)); :};

/* ================= USE ==================================================== */
use_list         ::= use:u use_list:ul {: RESULT = new Node(u).addChildren(ul); :}
                   | use:u             {: RESULT = new Node(u); :};
use              ::= USE IDENTIFIER:id
                       {: RESULT = new Node(new Node("use"), new Node(id)); :};

/* ================= METHOD ================================================= */
method_list      ::= method:m method_list:ml {: RESULT = new Node(m).addChildren(ml); :}
                   | method:m                {: RESULT = new Node(m); :};
method           ::= IDENTIFIER:id method_args:args method_retvals:mr block:b
                       {: RESULT = new Node(new Node(id), args, mr, b); :};
method_args      ::= OPEN_PAREN var_decl_list:vds CLOSE_PAREN
                       {: RESULT = vds; :};

/*================== INTERFACE ============================================== */
interface_list    ::= interface:i             {: RESULT = new Node(i); :}
                   | interface:i interface_list:il {: RESULT = new Node(i).addChildren(il); :};

interface        ::= IDENTIFIER:id method_args:args method_retvals:mr
                       {: RESULT = new Node(new Node(id), args, mr); :};


/* ================= VARIABLE DECLARATION =================================== */
var_decl_list    ::= var_decl_rec:vdr        {: RESULT = vdr; :}
                   | nothing;
var_decl_rec     ::= var_decl:vd COMMA var_decl_rec:vdr
                       {: RESULT = new Node(vd).addChildren(vdr); :}
                   | var_decl:vd             {: RESULT = new Node(vd); :};
var_decl         ::= IDENTIFIER:id COLON type:type
                       {: RESULT = new Node(new Node(id), type); :};

/* ================= TYPE =================================================== */
type             ::= primitive_type:pt       {: RESULT = pt; :}
                   | array_type:at           {: RESULT = at; :};
primitive_type   ::= INT                     {: RESULT = new Node("int"); :}
                   | BOOL                    {: RESULT = new Node("bool"); :};

// index: used for getting or setting array element: a[1][2][3] = 4, x = a[1][2][3]
// box:   used for array declaration: a: int[1][][3]
index            ::= OPEN_BRACKET expr:e CLOSE_BRACKET
                       {: RESULT = e; :}
                   | OPEN_BRACKET CLOSE_BRACKET
                       {: RESULT = null; :};
indexes          ::= indexes:is index:i
                       {: RESULT = new Node(new Node("[]"), is).addNodes(i); :}
                   | IDENTIFIER:id index:i
                       {: RESULT = new Node(new Node("[]"), new Node(id)).addNodes(i); :};
box              ::= OPEN_BRACKET expr:e CLOSE_BRACKET
                       {: RESULT = new Node(new Node("[]")).addNodes((Node) null, e); :}
                   | OPEN_BRACKET CLOSE_BRACKET
                       {: RESULT = new Node(new Node("[]")).addNodes((Node) null); :};
boxes            ::= box:b boxes:bs          {: RESULT = b.addHead(bs); :}
                   | box:b                   {: RESULT = b; :};
array_type       ::= primitive_type:pt boxes:bs
                       {: RESULT = bs.addHead(pt); :};

/* ================= RETVAL ================================================= */
// retval: stands for return value
method_retvals   ::= COLON retvals:rv        {: RESULT = rv; :}
                   | nothing;
retvals          ::= type:t COMMA retvals:rv {: RESULT = new Node(t).addChildren(rv); :}
                   | type:t                  {: RESULT = new Node(t); :};

/* ================= BLOCK/STATEMENT ======================================== */
block            ::= OPEN_BRACE stmt_list:sl CLOSE_BRACE
                       {: RESULT = sl; :}
                   | OPEN_BRACE stmt_list:sl return_statement:rs CLOSE_BRACE
                       {: RESULT = sl.addNodes(rs); :};
stmt_list        ::= stmt:st stmt_list:sl
                       {: RESULT = new Node(st).addChildren(sl); :}
                   | nothing;

// stmt_cond: purpose is to make sure "else" statement always follows the inner-most "if"
stmt             ::= stmt_cond:sc            {: RESULT = sc; :}
                   | if_statement:is         {: RESULT = is; :}
                   | while_statement:ws      {: RESULT = ws; :};
stmt_cond        ::= block:b                 {: RESULT = b; :}
                   | stmt_semi:ss            {: RESULT = ss; :};
stmt_semi        ::= stmt_semi:ss SEMICOLON  {: RESULT = ss; :}
                   | var_decl:vd             {: RESULT = vd; :} // without init
                   | assignment:as           {: RESULT = as; :}
                   | method_call:mc          {: RESULT = mc; :}
                   | length_statement:ls     {: RESULT = ls; :};

/* ================= ASSIGNMENT ============================================= */
// lhs: stands for left hand side
// var: stands for variable (cannot be a value or containing "[", "]", "{", "}")
assignment       ::= lhs:lhs GETS expr:expr  {: RESULT = new Node(new Node("="), lhs.sub(), expr); :};
lhs              ::= var:v COMMA lhs:lhs     {: RESULT = new Node(v).addChildren(lhs); :}
                   | var:v                   {: RESULT = new Node(v); :};
var              ::= IDENTIFIER:id           {: RESULT = new Node(id); :}
                   | UNDERSCORE              {: RESULT = new Node("_"); :}
                   | var_decl:vd             {: RESULT = vd; :}
                   | indexes:i                 {: RESULT = i; :};

/* ================= EXPRESSION ============================================= */
// Grouped operator and corresponding expressions into sever tiers.
// Tier 1 has the lowest precedency and tier 7 has the highest.
expr_list        ::= expr_rec:er                   {: RESULT = er; :}
                   | nothing;
expr_rec         ::= expr:e COMMA expr_rec:er      {: RESULT = new Node(e).addChildren(er); :}
                   | expr:e                        {: RESULT = new Node(e); :};
expr             ::= expr_t1:t                     {: RESULT = t; :};

expr_t1          ::= expr_t1:e1 t1op:o expr_t2:e2  {: RESULT = new Node(o,e1,e2); :}
                   | expr_t2:ee                    {: RESULT = ee; :};
expr_t2          ::= expr_t2:e1 t2op:o expr_t3:e2  {: RESULT = new Node(o,e1,e2); :}
                   | expr_t3:ee                    {: RESULT = ee; :};
expr_t3          ::= expr_t3:e1 t3op:o expr_t4:e2  {: RESULT = new Node(o,e1,e2); :}
                   | expr_t4:ee                    {: RESULT = ee; :};
expr_t4          ::= expr_t4:e1 t4op:o expr_t5:e2  {: RESULT = new Node(o,e1,e2); :}
                   | expr_t5:ee                    {: RESULT = ee; :};
expr_t5          ::= expr_t5:e1 t5op:o expr_t6:e2  {: RESULT = new Node(o,e1,e2); :}
                   | expr_t6:ee                    {: RESULT = ee; :};
expr_t6          ::= expr_t6:e1 t6op:o expr_t7:e2  {: RESULT = new Node(o,e1,e2); :}
                   | expr_t7:ee                    {: RESULT = ee; :};
expr_t7          ::= t7op:o expr_t7:e              {: RESULT = new Node(o,e); :}
                   | expr_atom:ee                  {: RESULT = ee; :};

expr_atom        ::= value:v                       {: RESULT = v; :}
                   | method_call:mc                {: RESULT = mc; :}
                   | length_statement:ls           {: RESULT = ls; :}
                   | OPEN_PAREN expr:e CLOSE_PAREN {: RESULT = e; :};

/* ================= OPERATION ============================================== */
t1op             ::= OR:o                    {: RESULT = new Node("|"); :};
t2op             ::= AND:o                   {: RESULT = new Node("&"); :};
t3op             ::= EQUAL:o                 {: RESULT = new Node("=="); :}
                   | NOT_EQUAL:o             {: RESULT = new Node("!="); :};
t4op             ::= GT:o                    {: RESULT = new Node(">"); :}
                   | LT:o                    {: RESULT = new Node("<"); :}
                   | GEQ:o                   {: RESULT = new Node(">="); :}
                   | LEQ:o                   {: RESULT = new Node("<="); :};
t5op             ::= PLUS:o                  {: RESULT = new Node("+"); :}
                   | MINUS:o                 {: RESULT = new Node("-"); :};
t6op             ::= TIMES:o                 {: RESULT = new Node("*"); :}
                   | DIVIDE:o                {: RESULT = new Node("/"); :}
                   | MODULO:o                {: RESULT = new Node("%"); :}
                   | TIMES_SHIFT:o           {: RESULT = new Node("*>>"); :};
t7op             ::= MINUS:o                 {: RESULT = new Node("-"); :}
                   | NOT:o                   {: RESULT = new Node("!"); :};

/* ================= LITERAL ================================================ */
value            ::= IDENTIFIER:id           {: RESULT = new Node(id); :}
                   | INTEGER_LITERAL:il      {: RESULT = new Node(il); :}
                   | STRING_LITERAL:sl       {: RESULT = new Node("\"" + sl + "\""); :}
                   | CHARACTER_LITERAL:cl    {: RESULT = new Node("\'" + cl + "\'"); :}
                   | TRUE                    {: RESULT = new Node("true"); :}
                   | FALSE                   {: RESULT = new Node("false"); :}
                   | array_literal:al        {: RESULT = al; :}
                   | indexes:i                 {: RESULT = i; :};
array_literal    ::= OPEN_BRACE expr_list:el CLOSE_BRACE
                       {: RESULT = el; :};

/* ================= IF/ELSE/WHILE ========================================== */
if_statement     ::= IF expr:e stmt:s
                       {: RESULT = new Node(new Node("if"), e.sub(), s); :}
                   | IF expr:e stmt_cond:s else_statement:es
                       {: RESULT = new Node(new Node("if"), e.sub(), s, es); :};
else_statement   ::= ELSE stmt:s
                       {: RESULT = s; :};
while_statement  ::= WHILE expr:e stmt:s
                       {: RESULT = new Node(new Node("while"), e.sub(), s); :};

/* ================= OTHER STATEMENTS ======================================= */
method_call      ::= IDENTIFIER:id OPEN_PAREN expr_list:el CLOSE_PAREN
                       {: RESULT = new Node(new Node(id)).addChildren(el); :};
return_statement ::= return_statement:rs SEMICOLON {: RESULT = rs; :}
                   | return_core:rc                {: RESULT = rc; :};
return_core      ::= RETURN expr_list:el
                       {: RESULT = new Node(new Node("return")).addChildren(el); :};
length_statement ::= LENGTH OPEN_PAREN expr:e CLOSE_PAREN
                       {: RESULT = new Node(new Node("length"), e); :};

nothing          ::= /* placeholder for epsilon */;
