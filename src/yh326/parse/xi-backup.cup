

                   | OPEN_BRACE stmt_list:sl return_statement:rs CLOSE_BRACE
                       {:RESULT = sl; RESULT.addNodes(rs);:};
stmt_list        ::= stmt:st stmt_list:sl
                       {:RESULT = new Node(st); RESULT.addChildren(sl);:}
                   | nothing;

// stmt_cond: purpose is to make sure "else" statement always follows the inner-most "if"
stmt             ::= stmt_cond:sc            {:RESULT = sc;:}
                   | if_statement:is         {:RESULT = is;:}
                   | while_statement:ws      {:RESULT = ws;:};
stmt_cond        ::= block:b                 {:RESULT = b;:}
                   | stmt_semi:ss            {:RESULT = ss;:};
stmt_semi        ::= stmt_core:sc            {:RESULT = sc;:}
                   | stmt_core:sc SEMICOLON  {:RESULT = sc;:};
stmt_core        ::= var_decl:vd             {:RESULT = vd;:} // without init
                   | assignment:as           {:RESULT = as;:}
                   | method_call:mc          {:RESULT = mc;:}
                   | length_statement:ls     {:RESULT = ls;:};

/* ================= ASSIGNMENT ============================================= */
// lhs: stands for left hand side
// var: stands for variable (cannot be a value or containing "[", "]", "{", "}")
assignment       ::= lhs:lhs GETS expr:expr  {:RESULT = new Node(new Node("="), lhs.sub(), expr);:};
lhs              ::= var:v COMMA lhs:lhs     {:RESULT = new Node(v); RESULT.addChildren(lhs);:}
                   | var:v                   {:RESULT = new Node(v);:};
var              ::= identifier:id           {:RESULT = id;:}
                   | UNDERSCORE              {:RESULT = new Node("_");:}
                   | var_decl:vd             {:RESULT = vd;:}
                   | subscripts:ss           {:RESULT = ss;:};

/* ================= EXPRESSION ============================================= */
// Grouped operator and corresponding expressions into sever tiers.
// Tier 1 has the lowest precedency and tier 7 has the highest.
expr_list        ::= expr_rec:er                   {:RESULT = er;:}
                   | nothing;
expr_rec         ::= expr:e COMMA expr_rec:er      {:RESULT = new Node(e); RESULT.addChildren(er);:}
                   | expr:e COMMA                  {:RESULT = new Node(e);:}
                   | expr:e                        {:RESULT = new Node(e);:};
expr             ::= expr_t1:t                     {:RESULT = t;:};
expr_t1          ::= expr_t1:e1 t1op:o expr_t2:e2  {:RESULT = new Node(o,e1,e2);:}
                   | expr_t2:ee                    {:RESULT = ee;:};
expr_t2          ::= expr_t2:e1 t2op:o expr_t3:e2  {:RESULT = new Node(o,e1,e2);:}
                   | expr_t3:ee                    {:RESULT = ee;:};
expr_t3          ::= expr_t3:e1 t3op:o expr_t4:e2  {:RESULT = new Node(o,e1,e2);:}
                   | expr_t4:ee                    {:RESULT = ee;:};
expr_t4          ::= expr_t4:e1 t4op:o expr_t5:e2  {:RESULT = new Node(o,e1,e2);:}
                   | expr_t5:ee                    {:RESULT = ee;:};
expr_t5          ::= expr_t5:e1 t5op:o expr_t6:e2  {:RESULT = new Node(o,e1,e2);:}
                   | expr_t6:ee                    {:RESULT = ee;:};
expr_t6          ::= expr_t6:e1 t6op:o expr_t7:e2  {:RESULT = new Node(o,e1,e2);:}
                   | expr_t7:ee                    {:RESULT = ee;:};
expr_t7          ::= t7op:o expr_t7:e              {:RESULT = new Node(o,e);:}
                   | expr_atom:ee                  {:RESULT = ee;:};

expr_atom        ::= identifier:id                 {:RESULT = id;:}
                   | INTEGER_LITERAL:il            {:RESULT = new Node(il);:}
                   | STRING_LITERAL:sl             {:RESULT = new Node("\"" + sl + "\"");:}
                   | CHARACTER_LITERAL:cl          {:RESULT = new Node("\'" + cl + "\'");:}
                   | TRUE                          {:RESULT = new Node("true");:}
                   | FALSE                         {:RESULT = new Node("false");:}
                   | subscripts:ss                 {:RESULT = ss;:}
                   | method_call:mc                {:RESULT = mc;:}
                   | length_statement:ls           {:RESULT = ls;:}
                   | OPEN_PAREN expr:e CLOSE_PAREN {:RESULT = e;:}
                   | OPEN_BRACE expr_list:el CLOSE_BRACE       {:RESULT = el;:};

/* ================= OPERATION ============================================== */
t1op             ::= OR                      {:RESULT = new Node("|");:};
t2op             ::= AND                     {:RESULT = new Node("&");:};
t3op             ::= EQUAL                   {:RESULT = new Node("==");:}
                   | NOT_EQUAL               {:RESULT = new Node("!=");:};
t4op             ::= GT                      {:RESULT = new Node(">");:}
                   | LT                      {:RESULT = new Node("<");:}
                   | GEQ                     {:RESULT = new Node(">=");:}
                   | LEQ                     {:RESULT = new Node("<=");:};
t5op             ::= PLUS                    {:RESULT = new Node("+");:}
                   | MINUS                   {:RESULT = new Node("-");:};
t6op             ::= TIMES                   {:RESULT = new Node("*");:}
                   | DIVIDE                  {:RESULT = new Node("/");:}
                   | MODULO                  {:RESULT = new Node("%");:}
                   | TIMES_SHIFT             {:RESULT = new Node("*>>");:};
t7op             ::= MINUS                   {:RESULT = new Node("-");:}
                   | NOT                     {:RESULT = new Node("!");:};

/* ================= IF/ELSE/WHILE ========================================== */
if_statement     ::= IF expr:e stmt:s
                       {:RESULT = new Node(new Node("if"), e.sub(), s);:}
                   | IF expr:e stmt_cond:s else_statement:es
                       {:RESULT = new Node(new Node("if"), e.sub(), s, es);:};
else_statement   ::= ELSE stmt:s
                       {:RESULT = s;:};
while_statement  ::= WHILE expr:e stmt:s
                       {:RESULT = new Node(new Node("while"), e.sub(), s);:};

/* ================= OTHER STATEMENTS ======================================= */
method_call      ::= identifier:id OPEN_PAREN expr_list:el CLOSE_PAREN
                       {:RESULT = new Node(id); RESULT.addChildren(el);:};
return_statement ::= return_statement:rs SEMICOLON {:RESULT = rs;:}
                   | return_core:rc                {:RESULT = rc;:};
return_core      ::= RETURN expr_list:el
                       {:RESULT = new Node(new Node("return")); RESULT.addChildren(el);:};
length_statement ::= LENGTH OPEN_PAREN expr:e CLOSE_PAREN
                       {:RESULT = new Node(new Node("length"), e);:};
