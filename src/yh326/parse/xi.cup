package yh326.gen;

import yh326.ast.node.*;
import yh326.ast.node.expr.*;
import yh326.ast.node.funcdecl.*;
import yh326.ast.node.interfc.*;
import yh326.ast.node.literal.*;
import yh326.ast.node.method.*;
import yh326.ast.node.operator.*;
import yh326.ast.node.operator.arithmetic.*;
import yh326.ast.node.operator.comparison.*;
import yh326.ast.node.operator.logical.*;
import yh326.ast.node.retval.*;
import yh326.ast.node.stmt.*;
import yh326.ast.node.type.*;
import yh326.ast.node.use.*;
import yh326.exception.ParsingException;
import yh326.lex.XiSymbol;


parser code  {:
  public void p(String s) {System.out.println(s);}
  public void report_error(String message, Object info) {}
  public void report_expected_token_ids() {}

  public void report_fatal_error(String message, Object info) throws ParsingException {
    if (info instanceof XiSymbol) {
      XiSymbol s = (XiSymbol) info;
      String p = "" + s.getLine() + ":" + s.getColumn() + " ";
        if (s.sym == sym.ERROR) {
          p += s.value;
        } else {
          p += "error: Unexpected token " + s.value;
        }
      throw new ParsingException(p);
    }
  }

  @SuppressWarnings("unused")
:};

terminal String IDENTIFIER;
terminal String STRING_LITERAL;
terminal String CHARACTER_LITERAL;
terminal String INTEGER_LITERAL;
terminal TRUE, FALSE;
terminal INT, BOOL;

terminal IF, ELSE, WHILE, /*BREAK,*/ RETURN, USE, LENGTH, PLUS, MINUS, TIMES,
  DIVIDE, MODULO, NOT, LT, LEQ, GT, GEQ, AND, OR, EQUAL, NOT_EQUAL, GETS,
  OPEN_BRACKET, CLOSE_BRACKET, OPEN_PAREN, CLOSE_PAREN, OPEN_BRACE, CLOSE_BRACE,
  COLON, COMMA, SEMICOLON, UNDERSCORE;

// These two are not include in the give xi.cup
terminal TIMES_SHIFT, ERROR;

nonterminal Node program;
nonterminal Identifier identifier;

nonterminal UseList use_list;
nonterminal Use use;

nonterminal MethodList method_list;
nonterminal Method method;
nonterminal FunctionTypeDeclList method_args;

nonterminal InterfaceList interface_list;
nonterminal Interface interface;

nonterminal FunctionTypeDeclList func_type_list, func_type_rec;
nonterminal FunctionTypeDecl func_type;

nonterminal RetvalList retvals_list, retvals;

nonterminal TypeNode type, type_func;
nonterminal PrimitiveTypeNode primitive_type;
nonterminal ArrayTypeNode array_type;
nonterminal ArrayTypeNodeFuncDecl array_type_func;

nonterminal ArrayTypeNode box, boxes;
nonterminal ArrayTypeNodeFuncDecl  box_func_decl, boxes_func_decl;

nonterminal Expr subscript;
nonterminal Subscript subscripts;
nonterminal Subscript_lhs subscripts_lhs;
nonterminal Subscript_rhs subscripts_rhs;
nonterminal Node subscriptable;
nonterminal Node subscriptable_lhs;
nonterminal Node subscriptable_rhs;

nonterminal StmtList block, stmt_list;
nonterminal Stmt stmt, stmt_cond, stmt_semi, stmt_core;
nonterminal VarDecl var_decl;

nonterminal Assign assignment;
nonterminal AssignToList assign_to_list;
nonterminal Node assign_to;

nonterminal ExprList expr_list, expr_rec;
nonterminal Expr expr, expr_atom;
nonterminal Expr expr_t1, expr_t2, expr_t3, expr_t4, expr_t5, expr_t6, expr_t7;
nonterminal Operator t1op, t2op, t3op, t4op, t5op, t6op, t7op;
nonterminal ArrayLiteral array_literal;

nonterminal Stmt if_statement, else_statement;
nonterminal While while_statement;
nonterminal MethodCall method_call;
nonterminal Return return_statement, return_core;
nonterminal Length length_expr;

nonterminal Node nothing;

start with program;

program          ::= use_list:ul method_list:ml
                       {:RESULT = new Node(ulleft, ulright, ul, ml);:}
                   | method_list:ml
                       {:RESULT = new Node(mlleft, mlright, new UseList(mlleft, mlright), ml);:}
                   | interface_list:il
                       {:RESULT = new Node(illeft, ilright, il);:}
                   | use_list:ul
                       {:RESULT = new Node(ulleft, ulright, ul, new MethodList(ulleft, ulright));:}
                   | nothing:n
                       {:RESULT = new Node(nleft, nright, 
                         new UseList(nleft, nright), new MethodList(nleft, nright));:};

identifier       ::= IDENTIFIER:id           {:RESULT = new Identifier(idleft, idright, id);:};
/* ================= USE ==================================================== */
use_list         ::= use:u use_list:ul
                       {:RESULT = new UseList(uleft, uright, u); RESULT.addChildren(ul);:}
                   | use:u
                       {:RESULT = new UseList(uleft, uright, u);:};
use              ::= USE:u identifier:id
                       {:RESULT = new Use(uleft, uright, id);:};

/* ================= METHOD ================================================= */

method_list      ::= method:m method_list:ml
                       {:RESULT = new MethodList(mleft, mright, m); RESULT.addChildren(ml);:}
                   | method:m
                       {:RESULT = new MethodList(mleft, mright, m);:};
method           ::= identifier:id method_args:args retvals_list:rets block:b
                       {:RESULT = new Method(idleft, idright, id, args, rets, b);:};

method_args      ::= OPEN_PAREN func_type_list:vdel CLOSE_PAREN
                       {:RESULT = vdel;:};

/*================== INTERFACE ============================================== */
interface_list   ::= interface:i
                       {:RESULT = new InterfaceList(ileft, iright, i);:}
                   | interface:i interface_list:il
                       {:RESULT = new InterfaceList(ileft, iright, i); RESULT.addChildren(il);:};

interface        ::= identifier:id method_args:args retvals_list:mr
                       {:RESULT = new Interface(idleft, idright, id, args, mr);:};

/* ================= FUNCTION TYPE DECLARATION ============================== */
// The following are for variable declaration in func args and retvals. Arrays
// must be "type_func"-"array_type_func"-"boxes_func_decl" (bracket must be empty).
func_type_list   ::= func_type_rec:vdr        {:RESULT = vdr;:}
                   | nothing;
func_type_rec    ::= func_type:vd COMMA func_type_rec:vdr
                       {:RESULT = new FunctionTypeDeclList(vdleft, vdright, vd); RESULT.addChildren(vdr);:}
                   | func_type:vd
                       {:RESULT = new FunctionTypeDeclList(vdleft, vdright, vd);:};
func_type        ::= identifier:id COLON type_func:t
                       {:RESULT = new FunctionTypeDecl(idleft, idright, id, t);:};

/* ================= RETVAL ================================================= */
// retval: stands for return value
retvals_list     ::= COLON retvals:rv        {:RESULT = rv;:}
                   | nothing;
retvals          ::= type_func:t COMMA retvals:rv
                       {:RESULT = new RetvalList(tleft, tright, t); RESULT.addChildren(rv);:}
                   | type_func:t
                       {:RESULT = new RetvalList(tleft, tright, t);:};

/* ================= TYPE =================================================== */
primitive_type   ::= INT:a                   {:RESULT = new PrimitiveTypeNode(aleft, aright, "int");:}
                   | BOOL:a                  {:RESULT = new PrimitiveTypeNode(aleft, aright, "bool");:};

type             ::= primitive_type:pt       {:RESULT = pt;:}
                   | array_type:at           {:RESULT = at;:};
array_type       ::= primitive_type:pt boxes:bs
                       {:RESULT = bs; RESULT.addHead(pt);:};

// Types in function declaration and return types,
// i.e. no expressions allowed in array brackets
type_func        ::= primitive_type:pt       {:RESULT = pt;:}
                   | array_type_func:at      {:RESULT = at;:};
array_type_func  ::= primitive_type:pt boxes_func_decl:bs
                       {:RESULT = bs; RESULT.addHead(pt);:};

// NOTE:
// box:       Used for array declaration: a: int[1][][3].
//            Expression between the bracket is optional.
// box_func_decl:   Used for array declaration for function argument and return value.
//            There must be NO expression between the bracket.
// subscript: Used for getting or setting array element: a[1][2][3] = 4, x = a[1][2][3].
//            There must be an expression between the bracket.

box              ::= OPEN_BRACKET:a expr:e CLOSE_BRACKET
                       {:RESULT = new ArrayTypeNode(aleft, aright);
                         RESULT.addNodes((Node) null, e);:}
                   | OPEN_BRACKET:a CLOSE_BRACKET
                       {:RESULT = new ArrayTypeNode(aleft, aright);
                         RESULT.addNodes((Node) null);:};
boxes            ::= box:b boxes:bs          {:RESULT = b; RESULT.addHead(bs);:}
                   | box:b                   {:RESULT = b;:};

box_func_decl    ::= OPEN_BRACKET:a CLOSE_BRACKET
                       {:RESULT = new ArrayTypeNodeFuncDecl(aleft, aright);
                         RESULT.addNodes((Node) null);:};
boxes_func_decl  ::= box_func_decl:b boxes_func_decl:bs  {:RESULT = b; RESULT.addHead(bs);:}
                   | box_func_decl:b               {:RESULT = b;:};


subscript        ::= OPEN_BRACKET expr:e CLOSE_BRACKET
                       {:RESULT = e;:};
subscripts_lhs   ::= subscripts_lhs:slhs subscript:s
                       {:RESULT = new Subscript_lhs(ssleft, ssright, slhs); RESULT.addNodes(s);:}
                   | subscriptable_lhs:sblhs subscript:s
                       {:RESULT = new Subscript_lhs(ssleft, ssright, sblhs); RESULT.addNodes(s);:};
subscripts_rhs   ::= subscripts_rhs:srhs subscript:s
                       {:RESULT = new Subscript_rhs(ssleft, ssright, srhs); RESULT.addNodes(s);:}
                   | subscriptable_rhs:sbrhs subscript:s
                       {:RESULT = new Subscript_rhs(ssleft, ssright, sbrhs); RESULT.addNodes(s);:};
subscripts       ::= subscripts:ss subscript:s
                       {:RESULT = new Subscript(ssleft, ssright, ss); RESULT.addNodes(s);:}
                   | subscriptable:sb subscript:s
                       {:RESULT = new Subscript(sbleft, sbright, sb); RESULT.addNodes(s);:};
subscriptable_lhs::= identifier:id           {:RESULT = id;:}
                   | method_call:mc          {:RESULT = mc;:};
subscriptable_rhs::= identifier:id           {:RESULT = id;:}
                   | method_call:mc          {:RESULT = mc;:}
                   | array_literal:al        {:RESULT = new Node(al);:};


/* ================= BLOCK/STATEMENT ======================================== */
block            ::= OPEN_BRACE stmt_list:sl CLOSE_BRACE
                       {:RESULT = sl;:}
                   | OPEN_BRACE stmt_list:sl return_statement:rs CLOSE_BRACE
                       {:RESULT = sl; RESULT.addNodes(rs);:};
stmt_list        ::= stmt:st stmt_list:sl
                       {:RESULT = new StmtList(stleft, stright, st); RESULT.addChildren(sl);:}
                   | nothing:a               {:RESULT = new StmtList(aleft, aright);:};

// stmt_cond: purpose is to make sure "else" statement always follows the inner-most "if"
// stmt_semi: a statement with a potential semicolon
// stmt_core: the statement itself
stmt             ::= stmt_cond:sc            {:RESULT = sc;:}
                   | if_statement:is         {:RESULT = is;:}
                   | while_statement:ws      {:RESULT = ws;:};
stmt_cond        ::= block:b                 {:RESULT = b;:}
                   | stmt_semi:ss            {:RESULT = ss;:};
stmt_semi        ::= stmt_core:sc            {:RESULT = sc;:}
                   | stmt_core:sc SEMICOLON  {:RESULT = sc;:};
stmt_core        ::= var_decl:vd             {:RESULT = vd;:} // without init
                   | assignment:as           {:RESULT = as;:}
                   | method_call:mc          {:RESULT = mc;:}
                   | length_expr:ls     {:RESULT = ls;:};

// var_decl is for variable declaration in statements.
// Arrays must be "type"-"array_type"-"boxes" (allows empty or non-empty bracket).
var_decl         ::= identifier:id COLON type:t
                       {:RESULT = new VarDecl(idleft, idright, id, t);:};

/* ================= ASSIGNMENT ============================================= */
// assign_to_list: left hand side
// assign_to: cannot be a value or containing "[", "]", "{", "}"
assignment       ::= assign_to_list:al GETS expr:expr
                       {:RESULT = new Assign(alleft, alright, al.sub(), expr);:};
assign_to_list   ::= assign_to:a COMMA assign_to_list:al
                       {:RESULT = new AssignToList(aleft, aright, a); RESULT.addChildren(al);:}
                   | assign_to:a
                       {:RESULT = new AssignToList(aleft, aright, a);:};
assign_to        ::= identifier:id           {:RESULT = id;:}
                   | UNDERSCORE:u            {:RESULT = new Underscore(uleft, uright);:}
                   | var_decl:vd             {:RESULT = vd;:}
                   | subscripts_lhs:ss       {:RESULT = ss;:};

/* ================= EXPRESSION ============================================= */
// Grouped operator and corresponding expressions into sever tiers.
// Tier 1 has the lowest precedency and tier 7 has the highest.
expr_list        ::= expr_rec:er                 {:RESULT = er;:}
                   | nothing;
expr_rec         ::= expr:e COMMA expr_rec:er    {:RESULT = new ExprList(eleft, eright, e); RESULT.addChildren(er);:}
                   | expr:e COMMA                {:RESULT = new ExprList(eleft, eright, e);:}
                   | expr:e                      {:RESULT = new ExprList(eleft, eright, e);:};
expr             ::= expr_t1:t
                       {:RESULT = t;:};
expr_t1          ::= expr_t1:e1 t1op:o expr_t2:e2
                       {:RESULT = new ExprNonAtom(e1left, e1right, o, e1, e2);:}
                   | expr_t2:ee
                       {:RESULT = ee;:};
expr_t2          ::= expr_t2:e1 t2op:o expr_t3:e2
                       {:RESULT = new ExprNonAtom(e1left, e1right, o, e1, e2);:}
                   | expr_t3:ee
                       {:RESULT = ee;:};
expr_t3          ::= expr_t3:e1 t3op:o expr_t4:e2
                       {:RESULT = new ExprNonAtom(e1left, e1right, o, e1, e2);:}
                   | expr_t4:ee
                       {:RESULT = ee;:};
expr_t4          ::= expr_t4:e1 t4op:o expr_t5:e2
                       {:RESULT = new ExprNonAtom(e1left, e1right, o, e1, e2);:}
                   | expr_t5:ee
                       {:RESULT = ee;:};
expr_t5          ::= expr_t5:e1 t5op:o expr_t6:e2
                       {:RESULT = new ExprNonAtom(e1left, e1right, o, e1, e2);:}
                   | expr_t6:ee
                       {:RESULT = ee;:};
expr_t6          ::= expr_t6:e1 t6op:o expr_t7:e2
                       {:RESULT = new ExprNonAtom(e1left, e1right, o, e1, e2);:}
                   | expr_t7:ee
                       {:RESULT = ee;:};
expr_t7          ::= t7op:o expr_t7:e
                       {:RESULT = new ExprNonAtom(oleft, oright, o, e);:}
                   | expr_atom:ee
                       {:RESULT = ee;:};

expr_atom        ::= identifier:id         {:RESULT = id;:}
                   | INTEGER_LITERAL:il    {:RESULT = new IntegerLiteral(illeft, ilright, il);:}
                   | STRING_LITERAL:sl     {:RESULT = new StringLiteral(slleft, slright, sl);:}
                   | CHARACTER_LITERAL:cl  {:RESULT = new CharacterLiteral(clleft, clright, cl);:}
                   | TRUE:a                {:RESULT = new TrueLiteral(aleft, aright);:}
                   | FALSE:a               {:RESULT = new FalseLiteral(aleft, aright);:}
                   | subscripts_rhs:ss     {:RESULT = ss;:}
                   | method_call:mc        {:RESULT = mc;:}
                   | length_expr:ls        {:RESULT = ls;:}
                   | OPEN_PAREN expr:e CLOSE_PAREN {:RESULT = e;:}
                   | array_literal:al      {:RESULT = al;:};

length_expr      ::= LENGTH:a OPEN_PAREN expr:e CLOSE_PAREN
                       {:RESULT = new Length(aleft, aright, e);:};
array_literal    ::= OPEN_BRACE expr_list:el CLOSE_BRACE
                       {:RESULT = new ArrayLiteral(aleft, aright); RESULT.addChildren(el);:};
 
/* ================= OPERATION ============================================== */
t1op             ::= OR:a           {:RESULT = new LogicOr(aleft, aright);:};
t2op             ::= AND:a          {:RESULT = new LogicAnd(aleft, aright);:};
t3op             ::= EQUAL:a        {:RESULT = new Equal(aleft, aright);:}
                   | NOT_EQUAL:a    {:RESULT = new NotEqual(aleft, aright);:};
t4op             ::= GT:a           {:RESULT = new GT(aleft, aright);:}
                   | LT:a           {:RESULT = new LT(aleft, aright);:}
                   | GEQ:a          {:RESULT = new GEQ(aleft, aright);:}
                   | LEQ:a          {:RESULT = new LEQ(aleft, aright);:};
t5op             ::= PLUS:a         {:RESULT = new Plus(aleft, aright);:}
                   | MINUS:a        {:RESULT = new Minus(aleft, aright);:};
t6op             ::= TIMES:a        {:RESULT = new Times(aleft, aright);:}
                   | DIVIDE:a       {:RESULT = new Divide(aleft, aright);:}
                   | MODULO:a       {:RESULT = new Modulus(aleft, aright);:}
                   | TIMES_SHIFT:a  {:RESULT = new ShiftTimes(aleft, aright);:};
t7op             ::= MINUS:a        {:RESULT = new ArithmeticNegation(aleft, aright);:}
                   | NOT:a          {:RESULT = new LogicNegation(aleft, aright);:};

/* ================= IF/ELSE/WHILE ========================================== */

if_statement     ::= IF:a expr:e stmt:s
                       {:RESULT = new If(aleft, aright, (Expr) e.sub(), s);:}
                   | IF:a expr:e stmt_cond:s else_statement:es
                       {:RESULT = new IfElse(aleft, aright, (Expr) e.sub(), s, es);:};
else_statement   ::= ELSE stmt:s
                       {:RESULT = s;:};
while_statement  ::= WHILE:a expr:e stmt:s
                       {:RESULT = new While(aleft, aright, (Expr) e.sub(), s);:};

/* ================= OTHER STATEMENTS ======================================= */
method_call      ::= identifier:id OPEN_PAREN expr_list:el CLOSE_PAREN
                       {:RESULT = new MethodCall(idleft, idright, id);
                         RESULT.addChildren(el);:};
return_statement ::= return_statement:rs SEMICOLON {:RESULT = rs;:}
                   | return_core:rc                {:RESULT = rc;:};
return_core      ::= RETURN:a expr_list:el
                       {:RESULT = new Return(aleft, aright); RESULT.addChildren(el);:};

nothing          ::= /* placeholder for epsilon */;
