package yh326.gen;

import yh326.ast.node.*;
import yh326.ast.node.interfc.*;
import yh326.ast.node.method.*;
import yh326.ast.node.retval.*;
import yh326.ast.node.stmt.*;
import yh326.ast.node.type.*;
import yh326.ast.node.use.*;
import yh326.ast.node.vardecl.*;
import yh326.exception.ParsingException;
import yh326.lex.XiSymbol;


parser code  {:
  public void p(String s) {System.out.println(s);}
  public void report_error(String message, Object info) {}
  public void report_expected_token_ids() {}

  public void report_fatal_error(String message, Object info) throws ParsingException {
    if (info instanceof XiSymbol) {
      XiSymbol s = (XiSymbol) info;
      String p = "" + s.getLine() + ":" + s.getColumn() + " ";
        if (s.sym == sym.ERROR) {
          p += s.value;
        } else {
          p += "error: Unexpected token " + s.value;
        }
      throw new ParsingException(p);
    }
  }

  @SuppressWarnings("unused")
:};

terminal String IDENTIFIER;
terminal String STRING_LITERAL;
terminal String CHARACTER_LITERAL;
terminal String INTEGER_LITERAL;
terminal TRUE, FALSE;
terminal INT, BOOL;

terminal IF, ELSE, WHILE, /*BREAK,*/ RETURN, USE, LENGTH, PLUS, MINUS, TIMES,
  DIVIDE, MODULO, NOT, LT, LEQ, GT, GEQ, AND, OR, EQUAL, NOT_EQUAL, GETS,
  OPEN_BRACKET, CLOSE_BRACKET, OPEN_PAREN, CLOSE_PAREN, OPEN_BRACE, CLOSE_BRACE,
  COLON, COMMA, SEMICOLON, UNDERSCORE;

// These two are not include in the give xi.cup
terminal TIMES_SHIFT, ERROR;

nonterminal Node program;
nonterminal Identifier identifier;

nonterminal UseList use_list;
nonterminal Use use;

nonterminal Node method_list, method;
nonterminal VarDeclList method_args;

nonterminal InterfaceList interface_list;
nonterminal Interface interface;

nonterminal VarDecl var_decl;
nonterminal VarDeclList var_decl_list, var_decl_rec;
nonterminal VarDeclFuncDecl var_decl_func;

nonterminal RetvalList retvals_list, retvals;

nonterminal TypeNode type;
nonterminal TypeNode primitive_type;
nonterminal TypeNode array_type;
nonterminal TypeNode type_func;
nonterminal TypeNode array_type_func;

nonterminal TypeNode box, boxes, box_func_decl, boxes_func_decl;

//nonterminal Node subscript, subscripts, subscriptable;

nonterminal Block block;//, stmt_list, stmt, stmt_cond, stmt_semi, stmt_core;
/*
nonterminal Node assignment, lhs, var;
nonterminal Node expr_list, expr_rec, expr, expr_atom;
nonterminal Node expr_t1, expr_t2, expr_t3, expr_t4, expr_t5, expr_t6, expr_t7;
nonterminal Node t1op, t2op, t3op, t4op, t5op, t6op, t7op;
nonterminal Node if_statement, else_statement, while_statement;
nonterminal Node method_call,return_statement, return_core, length_statement;
*/

nonterminal Node nothing;

start with program;

program          ::= use_list:ul method_list:ml
                       {:RESULT = new Node(ulleft, ulright, ul, ml);:}
                   | method_list:ml
                       {:RESULT = new Node(mlleft, mlright, new Node(mlleft, mlright), ml);:}
                   | interface_list:il
                       {:RESULT = new Node(illeft, ilright, il);:}
                   | use_list:ul
                       {:RESULT = new Node(ulleft, ulright, ul, new Node(ulleft, ulright));:}
                   | nothing:n
                       {:RESULT = new Node(nleft, nright, 
                                           new Node(nleft, nright), new Node(nleft, nright));:};

identifier       ::= IDENTIFIER:id           {:RESULT = new Identifier(idleft, idright, id);:};
/* ================= USE ==================================================== */
use_list         ::= use:u use_list:ul
                       {:RESULT = new UseList(uleft, uright, u); RESULT.addChildren(ul);:}
                   | use:u
                       {:RESULT = new UseList(uleft, uright, u);:};
use              ::= USE:u identifier:id
                       {:RESULT = new Use(uleft, uright, id);:};

/* ================= METHOD ================================================= */

method_list      ::= method:m method_list:ml
                       {:RESULT = new MethodList(mleft, mright, m); RESULT.addChildren(ml);:}
                   | method:m
                       {:RESULT = new MethodList(mleft, mright, m);:};
method           ::= identifier:id method_args:args retvals_list:rets block:b
                       {:RESULT = new Method(idleft, idright, id, args, rets, b);:};

method_args      ::= OPEN_PAREN var_decl_list:vdel CLOSE_PAREN
                       {:RESULT = vdel;:};

/*================== INTERFACE ============================================== */
interface_list   ::= interface:i
                       {:RESULT = new InterfaceList(ileft, iright, i);:}
                   | interface:i interface_list:il
                       {:RESULT = new InterfaceList(ileft, iright, i); RESULT.addChildren(il);:};

interface        ::= identifier:id method_args:args retvals_list:mr
                       {:RESULT = new Interface(idleft, idright, id, args, mr);:};

/* ================= VARIABLE DECLARATION =================================== */
// var_decl is for variable declaration in statements.
// Arrays must be "type"-"array_type"-"boxes" (allows empty or non-empty bracket).
//var_decl         ::= identifier:id COLON type:t
//                       {:RESULT = new VarDecl(id, t);:};

// The following are for variable declaration in func args and retvals. Arrays
// must be "type_func"-"array_type_func"-"boxes_func_decl" (bracket must be empty).
var_decl_list    ::= var_decl_rec:vdr        {:RESULT = vdr;:}
                   | nothing;
var_decl_rec     ::= var_decl_func:vd COMMA var_decl_rec:vdr
                       {:RESULT = new VarDeclList(vdleft, vdright, vd); RESULT.addChildren(vdr);:}
                   | var_decl_func:vd
                       {:RESULT = new VarDeclList(vdleft, vdright, vd);:};
var_decl_func    ::= identifier:id COLON type_func:t
                       {:RESULT = new VarDeclFuncDecl(idleft, idright, id, t);:};

/* ================= RETVAL ================================================= */
// retval: stands for return value
retvals_list     ::= COLON retvals:rv            {:RESULT = rv;:}
                   | nothing;
retvals          ::= type_func:t COMMA retvals:rv
                       {:RESULT = new RetvalList(tleft, tright, t); RESULT.addChildren(rv);:}
                   | type_func:t
                       {:RESULT = new RetvalList(tleft, tright, t);:};

/* ================= TYPE =================================================== */
type             ::= primitive_type:pt       {:RESULT = pt;:}
                   | array_type:at           {:RESULT = at;:};
primitive_type   ::= INT:a                   {:RESULT = new PrimitiveTypeNode(aleft, aright, "int");:}
                   | BOOL:a                  {:RESULT = new PrimitiveTypeNode(aleft, aright, "bool");:};
array_type       ::= primitive_type:pt boxes:bs
                       {:RESULT = bs; RESULT.addHead(pt);:};

type_func        ::= primitive_type:pt       {:RESULT = pt;:}
                   | array_type_func:at       {:RESULT = at;:};
array_type_func  ::= primitive_type:pt boxes_func_decl:bs
                       {:RESULT = bs; RESULT.addHead(pt);:};

// NOTE:
// box:       Used for array declaration: a: int[1][][3].
//            Expression between the bracket is optional.
// box_func_decl:   Used for array declaration for function argument and return value.
//            There must be NO expression between the bracket.
// subscript: Used for getting or setting array element: a[1][2][3] = 4, x = a[1][2][3].
//            There must be an expression between the bracket.

/*
box              ::= OPEN_BRACKET:a expr:e CLOSE_BRACKET
                       {:RESULT = new TypeNode(aleft, aright, new TypeNode(aleft, aright, "[]"));
                         RESULT.addNodes((Node) null, e);:}
                   | OPEN_BRACKET:a CLOSE_BRACKET
                       {:RESULT = new TypeNode(aleft, aright, new TypeNode(aleft, aright, "[]"));
                         RESULT.addNodes((Node) null);:};
boxes            ::= box:b boxes:bs          {:RESULT = b; RESULT.addHead(bs);:}
                   | box:b                   {:RESULT = b;:};
*/

box_func_decl    ::= OPEN_BRACKET:a CLOSE_BRACKET
                       {:RESULT = new ArrayTypeNodeFuncDecl(aleft, aright);
                         RESULT.addNodes((Node) null);:};
boxes_func_decl  ::= box_func_decl:b boxes_func_decl:bs  {:RESULT = b; RESULT.addHead(bs);:}
                   | box_func_decl:b               {:RESULT = b;:};

/*
subscript        ::= OPEN_BRACKET expr:e CLOSE_BRACKET
                       {:RESULT = e;:};
subscripts       ::= subscripts:ss subscript:s
                       {:RESULT = new TypeNode(new TypeNode("[]"), ss); RESULT.addNodes(s);:}
                   | subscriptable:sb subscript:s
                       {:RESULT = new TypeNode(new TypeNode("[]"), sb); RESULT.addNodes(s);:};
subscriptable    ::= identifier:id           {:RESULT = id;:}
                   | method_call:mc          {:RESULT = new Node(mc);:};
// TODO            | array_literal:al        {:RESULT = new Node(al);:};
*/
/* ================= BLOCK/STATEMENT ======================================== */
//block            ::= OPEN_BRACE stmt_list:sl CLOSE_BRACE
block            ::= OPEN_BRACE:a CLOSE_BRACE
                       {:RESULT = new Block(aleft, aright);:};

//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// SEE xi-backup.cup for the missing part
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

nothing          ::= /* placeholder for epsilon */;
