package yh326.gen;

import yh326.ast.node.*;
import yh326.ast.node.interfc.*;
import yh326.ast.node.retval.*;
import yh326.ast.node.type.*;
import yh326.ast.node.use.*;
import yh326.ast.node.vardecl.*;
import yh326.exception.ParsingException;
import yh326.lex.XiSymbol;


parser code  {:
  public void p(String s) {System.out.println(s);}
  public void report_error(String message, Object info) {}
  public void report_expected_token_ids() {}

  public void report_fatal_error(String message, Object info) throws ParsingException {
    if (info instanceof XiSymbol) {
      XiSymbol s = (XiSymbol) info;
      String p = "" + s.getLine() + ":" + s.getColumn() + " ";
        if (s.sym == sym.ERROR) {
          p += s.value;
        } else {
          p += "error: Unexpected token " + s.value;
        }
      throw new ParsingException(p);
    }
  }

  @SuppressWarnings("unused")
:};

terminal String IDENTIFIER;
terminal String STRING_LITERAL;
terminal String CHARACTER_LITERAL;
terminal String INTEGER_LITERAL;
terminal TRUE, FALSE;
terminal INT, BOOL;

terminal IF, ELSE, WHILE, /*BREAK,*/ RETURN, USE, LENGTH, PLUS, MINUS, TIMES,
  DIVIDE, MODULO, NOT, LT, LEQ, GT, GEQ, AND, OR, EQUAL, NOT_EQUAL, GETS,
  OPEN_BRACKET, CLOSE_BRACKET, OPEN_PAREN, CLOSE_PAREN, OPEN_BRACE, CLOSE_BRACE,
  COLON, COMMA, SEMICOLON, UNDERSCORE;

// These two are not include in the give xi.cup
terminal TIMES_SHIFT, ERROR;

nonterminal Node program;
nonterminal Identifier identifier;

nonterminal UseList use_list;
nonterminal Use use;

nonterminal Node method_list, method;
nonterminal VarDeclList method_args;

nonterminal InterfaceList interface_list;
nonterminal Interface interface;

nonterminal VarDecl var_decl;
nonterminal VarDeclList var_decl_list, var_decl_rec;
nonterminal VarDeclFunction var_decl_func;

nonterminal RetvalList retvals_list, retvals;

nonterminal TypeNode type;
nonterminal TypeNode primitive_type;
nonterminal TypeNode array_type;
nonterminal TypeNode type_emp;
nonterminal TypeNode array_type_emp;

nonterminal TypeNode box, boxes, box_emp, boxes_emp;


nonterminal Node nothing;

start with program;

program          ::= use_list:ul method_list:ml
                       {:RESULT = new Node(ulleft, ulright, ul, ml);:}
                   | method_list:ml
                       {:RESULT = new Node(mlleft, mlright, new Node(mlleft, mlright), ml);:}
                   | interface_list:il
                       {:RESULT = new Node(illeft, ilright, il);:}
                   | use_list:ul
                       {:RESULT = new Node(ulleft, ulright, ul, new Node(ulleft, ulright));:}
                   | nothing:n
                       {:RESULT = new Node(nleft, nright, 
                                           new Node(nleft, nright), new Node(nleft, nright));:};

identifier       ::= IDENTIFIER:id           {:RESULT = new Identifier(idleft, idright, id);:};
/* ================= USE ==================================================== */
use_list         ::= use:u use_list:ul
                       {:RESULT = new UseList(uleft, uright, u); RESULT.addChildren(ul);:}
                   | use:u
                       {:RESULT = new UseList(uleft, uright, u);:};
use              ::= USE:u identifier:id
                       {:RESULT = new Use(uleft, uright, id);:};

/* ================= METHOD ================================================= */
/*
method_list      ::= method:m method_list:ml {:RESULT = new Node(m); RESULT.addChildren(ml);:}
                   | method:m                {:RESULT = new Node(m);:};
method           ::= identifier:id method_args:args retvals_list:mr block:b
                       {:RESULT = new Node(id, args, mr, b);:};
*/
method_args      ::= OPEN_PAREN var_decl_list:vdel CLOSE_PAREN
                       {:RESULT = vdel;:};

/*================== INTERFACE ============================================== */
interface_list   ::= interface:i
                       {:RESULT = new InterfaceList(ileft, iright, i);:}
                   | interface:i interface_list:il
                       {:RESULT = new InterfaceList(ileft, iright, i); RESULT.addChildren(il);:};

interface        ::= identifier:id method_args:args retvals_list:mr
                       {:RESULT = new Interface(idleft, idright, id, args, mr);:};

/* ================= VARIABLE DECLARATION =================================== */
// var_decl is for variable declaration in statements.
// Arrays must be "type"-"array_type"-"boxes" (allows empty or non-empty bracket).
//var_decl         ::= identifier:id COLON type:t
//                       {:RESULT = new VarDecl(id, t);:};

// The following are for variable declaration in func args and retvals. Arrays
// must be "type_emp"-"array_type_emp"-"boxes_emp" (bracket must be empty).
var_decl_list    ::= var_decl_rec:vdr        {:RESULT = vdr;:}
                   | nothing;
var_decl_rec     ::= var_decl_func:vd COMMA var_decl_rec:vdr
                       {:RESULT = new VarDeclList(vdleft, vdright, vd); RESULT.addChildren(vdr);:}
                   | var_decl_func:vd
                       {:RESULT = new VarDeclList(vdleft, vdright, vd);:};
var_decl_func    ::= identifier:id COLON type_emp:t
                       {:RESULT = new VarDeclFunction(idleft, idright, id, t);:};

/* ================= RETVAL ================================================= */
// retval: stands for return value
retvals_list     ::= COLON retvals:rv            {:RESULT = rv;:}
                   | nothing;
retvals          ::= type_emp:t COMMA retvals:rv
                       {:RESULT = new RetvalList(tleft, tright, t); RESULT.addChildren(rv);:}
                   | type_emp:t
                       {:RESULT = new RetvalList(tleft, tright, t);:};

/* ================= TYPE =================================================== */
type             ::= primitive_type:pt       {:RESULT = pt;:}
                   | array_type:at           {:RESULT = at;:};
primitive_type   ::= INT:a                   {:RESULT = new PrimitiveTypeNode(aleft, aright, "int");:}
                   | BOOL:a                  {:RESULT = new PrimitiveTypeNode(aleft, aright, "bool");:};
array_type       ::= primitive_type:pt boxes:bs
                       {:RESULT = bs; RESULT.addHead(pt);:};

type_emp         ::= primitive_type:pt       {:RESULT = pt;:}
                   | array_type_emp:at       {:RESULT = at;:};
array_type_emp   ::= primitive_type:pt boxes_emp:bs
                       {:RESULT = bs; RESULT.addHead(pt);:};

// NOTE:
// box:       Used for array declaration: a: int[1][][3].
//            Expression between the bracket is optional.
// box_emp:   Used for array declaration for function argument and return value.
//            There must be NO expression between the bracket.
// subscript: Used for getting or setting array element: a[1][2][3] = 4, x = a[1][2][3].
//            There must be an expression between the bracket.
box              ::= OPEN_BRACKET:a expr:e CLOSE_BRACKET
                       {:RESULT = new TypeNode(aleft, aright, new TypeNode(aleft, aright, "[]"));
                         RESULT.addNodes((Node) null, e);:}
                   | OPEN_BRACKET:a CLOSE_BRACKET
                       {:RESULT = new TypeNode(aleft, aright, new TypeNode(aleft, aright, "[]"));
                         RESULT.addNodes((Node) null);:};
boxes            ::= box:b boxes:bs          {:RESULT = b; RESULT.addHead(bs);:}
                   | box:b                   {:RESULT = b;:};
box_emp          ::= OPEN_BRACKET:a CLOSE_BRACKET
                       {:RESULT = new TypeNode(aleft, aright, new TypeNode(aleft, aright, "[]"));
                         RESULT.addNodes((Node) null);:};
boxes_emp        ::= box_emp:b boxes_emp:bs  {:RESULT = b; RESULT.addHead(bs);:}
                   | box_emp:b               {:RESULT = b;:};
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// SEE xi-backup.cup for the missing part
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
nothing          ::= /* placeholder for epsilon */;
